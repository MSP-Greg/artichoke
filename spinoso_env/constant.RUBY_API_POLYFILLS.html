<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Ruby implementations of the full [`ENV`] API."><meta name="keywords" content="rust, rustlang, rust-lang, RUBY_API_POLYFILLS"><title>RUBY_API_POLYFILLS in spinoso_env - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../spinoso_env/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.png" alt="logo"></div>
        </a><div class="sidebar-elems"><h2 class="location">Other items in<br><a href="index.html">spinoso_env</a></h2><div id="sidebar-vars" data-name="RUBY_API_POLYFILLS" data-ty="constant" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../spinoso_env/index.html"><img class="rust-logo" src="../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Constant <a href="index.html">spinoso_env</a>::<wbr><a class="constant" href="#">RUBY_API_POLYFILLS</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/spinoso_env/lib.rs.html#126" title="goto source code">[src]</a></span></h1><div class="docblock item-decl"><pre class="rust const"><code>pub const RUBY_API_POLYFILLS: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = &quot;# frozen_string_literal: true\n\nENV = Object.new\n\nclass &lt;&lt; ENV\n  def [](name)\n    @backend ||= ::Artichoke::Environ.new\n    @backend[name]\n  end\n\n  def []=(name, value)\n    @backend ||= ::Artichoke::Environ.new\n    @backend[name] = value\n  end\n\n  def assoc(name)\n    name = name.to_str unless name.is_a?(String)\n    value = self[name]\n    return nil if value.nil?\n\n    [name, value]\n  end\n\n  def clear\n    to_h.each do |var_name, var_value|\n      self[var_name] = nil unless var_value.nil?\n    end\n\n    to_h\n  end\n\n  def delete(name)\n    value = self[name]\n    if value.nil?\n      yield name if block_given?\n      return nil\n    end\n\n    self[name] = nil\n    yield name if block_given?\n\n    value\n  end\n\n  def delete_if\n    return to_enum(:delete_if) unless block_given?\n\n    to_h.each do |key, value|\n      delete(key) if yield key, value\n    end\n    to_h\n  end\n\n  def each(&amp;blk)\n    return to_enum(:each) unless block_given?\n\n    to_h.each(&amp;blk)\n  end\n\n  def each_key(&amp;blk)\n    return to_enum(:each_key) unless block_given?\n\n    to_h.each_key(&amp;blk)\n  end\n\n  def each_pair(&amp;blk)\n    return to_enum(:each_pair) unless block_given?\n\n    to_h.each_pair(&amp;blk)\n  end\n\n  def each_value(&amp;blk)\n    return to_enum(:each_value) unless block_given?\n\n    to_h.each_value(&amp;blk)\n  end\n\n  def empty?\n    to_h.empty?\n  end\n\n  def fetch(name, default = (not_set = true))\n    warn \&#39;warning: block supersedes default value argument\&#39; if !not_set &amp;&amp; block_given?\n\n    name =\n      if name.is_a?(String)\n        name\n      elsif name.respond_to?(:to_str)\n        converted = name.to_str\n        unless converted.is_a?(String)\n          raise TypeError, \&quot;can\&#39;t convert #{name.class} to String (#{name.class}#to_str gives #{converted.class})\&quot;\n        end\n\n        converted\n      else\n        cls = name.class\n        cls = \&#39;nil\&#39; if name.nil?\n\n        raise TypeError, \&quot;no implicit conversion of #{cls} into String\&quot;\n      end\n\n    value = self[name]\n    return value unless value.nil?\n    return yield name if block_given?\n    return default unless not_set\n\n    raise KeyError.new(\&quot;key not found: #{name.inspect}\&quot;, receiver: self, key: name)\n  end\n\n  def filter(&amp;blk)\n    return to_enum(:filter) unless block_given?\n\n    to_h.select(&amp;blk)\n  end\n\n  def filter!(&amp;blk)\n    return to_enum(:filter!) unless block_given?\n\n    select!(&amp;blk)\n  end\n\n  def has_key?(name) # rubocop:disable Naming/PredicateName\n    to_h.key?(name)\n  end\n\n  def has_value?(value) # rubocop:disable Naming/PredicateName\n    to_h.value?(value)\n  end\n\n  def include?(name)\n    to_h.key?(name)\n  end\n\n  def index(value)\n    to_h.key(value)\n  end\n\n  def inspect\n    to_h.to_s\n  end\n\n  def invert\n    to_h.invert\n  end\n\n  def keep_if\n    return to_enum(:keep_if) unless block_given?\n\n    to_h.each do |key, value|\n      delete(key) unless yield key, value\n    end\n    to_h\n  end\n\n  def key(value)\n    to_h.key(value)\n  end\n\n  def key?(name)\n    !self[name].nil?\n  end\n\n  def keys\n    to_h.keys\n  end\n\n  def length\n    to_h.length\n  end\n\n  def member?(name)\n    !self[name].nil?\n  end\n\n  def merge!(hash)\n    hash.each do |key, value|\n      value = yield(key, self[key], value) if block_given? &amp;&amp; key?(key)\n      self[key] = value\n    end\n\n    to_h\n  end\n  alias update merge!\n\n  def rassoc(value)\n    value = value.to_str unless value.is_a?(String)\n    to_h.each do |k, v|\n      return [k, v] if v == value\n    end\n    nil\n  end\n\n  def rehash\n    nil\n  end\n\n  def reject(&amp;blk)\n    return to_enum(:reject) unless block_given?\n\n    to_h.delete_if(&amp;blk)\n  end\n\n  def reject!\n    return to_enum(:reject!) unless block_given?\n\n    modified = false\n    to_h.each do |key, value|\n      if yield key, value\n        delete(key)\n        modified = true\n      end\n    end\n\n    return self if modified\n\n    nil\n  end\n\n  def replace(hash)\n    hash.each do |k, v|\n      self[k] = v\n    end\n    select! { |k, _| hash.key?(k) }\n  end\n\n  def select(&amp;blk)\n    return to_enum(:select) unless block_given?\n\n    to_h.select(&amp;blk)\n  end\n\n  def select!(&amp;blk)\n    return to_enum(:select!) unless block_given?\n\n    env = to_h\n    # collect all the keys where the block evaluates to false\n    to_remove = env.reject(&amp;blk)\n\n    # returns nil if no changes were made\n    return nil if to_remove.empty?\n\n    to_remove.each do |key, _|\n      delete(key)\n    end\n    self\n  end\n\n  def shift\n    envs = to_h\n    return nil if envs.nil? || envs.empty?\n\n    name, value = envs.shift\n    self[name] = nil\n    [name, value]\n  end\n\n  def size\n    to_h.size\n  end\n\n  def slice(*keys)\n    to_h.slice(*keys)\n  end\n\n  def store(name, value)\n    self[name] = value\n  end\n\n  def to_a\n    to_h.to_a\n  end\n\n  def to_h\n    @backend ||= ::Artichoke::Environ.new\n    h = @backend.to_h\n    return h unless block_given?\n\n    pairs = h.each_pair.map do |name, value|\n      tx = yield(name, value)\n      if tx.is_a?(Array)\n        raise ArgumentError, \&quot;element has wrong array length (expected 2, was #{tx.length})\&quot; if tx.length != 2\n\n        tx\n      elsif tx.respond_to?(:to_ary)\n        pair = tx.to_ary\n        unless pair.is_a?(Array)\n          raise TypeError, \&quot;can\&#39;t convert #{tx.class} to Array (#{tx.class}#to_ary gives #{pair.class})\&quot;\n        end\n        raise ArgumentError, \&quot;element has wrong array length (expected 2, was #{pair.length})\&quot; if pair.length != 2\n\n        pair\n      else\n        raise TypeError, \&quot;wrong element type #{tx.class} (expected array)\&quot;\n      end\n    end\n    pairs.to_h\n  end\n\n  def to_hash\n    to_h\n  end\n\n  def to_s\n    \&#39;ENV\&#39;\n  end\n\n  def value?(name)\n    to_h.value?(name)\n  end\n\n  def values\n    to_h.values\n  end\n\n  def values_at(*names)\n    to_h.values_at(*names)\n  end\nend\n&quot;;</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Ruby implementations of the full <a href="https://ruby-doc.org/core-2.6.3/ENV.html"><code>ENV</code></a> API.</p>
<p>This crate only implements enough of the <code>ENV</code> API in native code to glue
the system APIs to the interpreter. <a href="https://ruby-doc.org/core-2.6.3/ENV.html"><code>ENV</code></a> offers a rich, <a href="https://ruby-doc.org/core-2.6.3/Hash.html"><code>Hash</code></a>-like API
on top of the raw names and values.</p>
<p>This constant contains Ruby source code that implements the remainder of
these APIs on top of the core accessors and mutators in this crate.</p>
<h2 id="ruby-source" class="section-header"><a href="#ruby-source">Ruby Source</a></h2><div class="example-wrap"><pre class="language-ruby"><code>
ENV = Object.new

class &lt;&lt; ENV
  def [](name)
    @backend ||= ::Artichoke::Environ.new
    @backend[name]
  end

  def []=(name, value)
    @backend ||= ::Artichoke::Environ.new
    @backend[name] = value
  end

  def assoc(name)
    name = name.to_str unless name.is_a?(String)
    value = self[name]
    return nil if value.nil?

    [name, value]
  end

  def clear
    to_h.each do |var_name, var_value|
      self[var_name] = nil unless var_value.nil?
    end

    to_h
  end

  def delete(name)
    value = self[name]
    if value.nil?
      yield name if block_given?
      return nil
    end

    self[name] = nil
    yield name if block_given?

    value
  end

  def delete_if
    return to_enum(:delete_if) unless block_given?

    to_h.each do |key, value|
      delete(key) if yield key, value
    end
    to_h
  end

  def each(&amp;blk)
    return to_enum(:each) unless block_given?

    to_h.each(&amp;blk)
  end

  def each_key(&amp;blk)
    return to_enum(:each_key) unless block_given?

    to_h.each_key(&amp;blk)
  end

  def each_pair(&amp;blk)
    return to_enum(:each_pair) unless block_given?

    to_h.each_pair(&amp;blk)
  end

  def each_value(&amp;blk)
    return to_enum(:each_value) unless block_given?

    to_h.each_value(&amp;blk)
  end

  def empty?
    to_h.empty?
  end

  def fetch(name, default = (not_set = true))
    warn &#39;warning: block supersedes default value argument&#39; if !not_set &amp;&amp; block_given?

    name =
      if name.is_a?(String)
        name
      elsif name.respond_to?(:to_str)
        converted = name.to_str
        unless converted.is_a?(String)
          raise TypeError, &quot;can&#39;t convert #{name.class} to String (#{name.class}#to_str gives #{converted.class})&quot;
        end

        converted
      else
        cls = name.class
        cls = &#39;nil&#39; if name.nil?

        raise TypeError, &quot;no implicit conversion of #{cls} into String&quot;
      end

    value = self[name]
    return value unless value.nil?
    return yield name if block_given?
    return default unless not_set

    raise KeyError.new(&quot;key not found: #{name.inspect}&quot;, receiver: self, key: name)
  end

  def filter(&amp;blk)
    return to_enum(:filter) unless block_given?

    to_h.select(&amp;blk)
  end

  def filter!(&amp;blk)
    return to_enum(:filter!) unless block_given?

    select!(&amp;blk)
  end

  def has_key?(name) # rubocop:disable Naming/PredicateName
    to_h.key?(name)
  end

  def has_value?(value) # rubocop:disable Naming/PredicateName
    to_h.value?(value)
  end

  def include?(name)
    to_h.key?(name)
  end

  def index(value)
    to_h.key(value)
  end

  def inspect
    to_h.to_s
  end

  def invert
    to_h.invert
  end

  def keep_if
    return to_enum(:keep_if) unless block_given?

    to_h.each do |key, value|
      delete(key) unless yield key, value
    end
    to_h
  end

  def key(value)
    to_h.key(value)
  end

  def key?(name)
    !self[name].nil?
  end

  def keys
    to_h.keys
  end

  def length
    to_h.length
  end

  def member?(name)
    !self[name].nil?
  end

  def merge!(hash)
    hash.each do |key, value|
      value = yield(key, self[key], value) if block_given? &amp;&amp; key?(key)
      self[key] = value
    end

    to_h
  end
  alias update merge!

  def rassoc(value)
    value = value.to_str unless value.is_a?(String)
    to_h.each do |k, v|
      return [k, v] if v == value
    end
    nil
  end

  def rehash
    nil
  end

  def reject(&amp;blk)
    return to_enum(:reject) unless block_given?

    to_h.delete_if(&amp;blk)
  end

  def reject!
    return to_enum(:reject!) unless block_given?

    modified = false
    to_h.each do |key, value|
      if yield key, value
        delete(key)
        modified = true
      end
    end

    return self if modified

    nil
  end

  def replace(hash)
    hash.each do |k, v|
      self[k] = v
    end
    select! { |k, _| hash.key?(k) }
  end

  def select(&amp;blk)
    return to_enum(:select) unless block_given?

    to_h.select(&amp;blk)
  end

  def select!(&amp;blk)
    return to_enum(:select!) unless block_given?

    env = to_h
    to_remove = env.reject(&amp;blk)

    return nil if to_remove.empty?

    to_remove.each do |key, _|
      delete(key)
    end
    self
  end

  def shift
    envs = to_h
    return nil if envs.nil? || envs.empty?

    name, value = envs.shift
    self[name] = nil
    [name, value]
  end

  def size
    to_h.size
  end

  def slice(*keys)
    to_h.slice(*keys)
  end

  def store(name, value)
    self[name] = value
  end

  def to_a
    to_h.to_a
  end

  def to_h
    @backend ||= ::Artichoke::Environ.new
    h = @backend.to_h
    return h unless block_given?

    pairs = h.each_pair.map do |name, value|
      tx = yield(name, value)
      if tx.is_a?(Array)
        raise ArgumentError, &quot;element has wrong array length (expected 2, was #{tx.length})&quot; if tx.length != 2

        tx
      elsif tx.respond_to?(:to_ary)
        pair = tx.to_ary
        unless pair.is_a?(Array)
          raise TypeError, &quot;can&#39;t convert #{tx.class} to Array (#{tx.class}#to_ary gives #{pair.class})&quot;
        end
        raise ArgumentError, &quot;element has wrong array length (expected 2, was #{pair.length})&quot; if pair.length != 2

        pair
      else
        raise TypeError, &quot;wrong element type #{tx.class} (expected array)&quot;
      end
    end
    pairs.to_h
  end

  def to_hash
    to_h
  end

  def to_s
    &#39;ENV&#39;
  end

  def value?(name)
    to_h.value?(name)
  end

  def values
    to_h.values
  end

  def values_at(*names)
    to_h.values_at(*names)
  end
end</code></pre></div></div></details></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="spinoso_env" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0-nightly (f8abed9ed 2021-12-26)" ></div>
</body></html>